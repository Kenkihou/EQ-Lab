<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>構造力学シミュレーターver5.1_impulse</title>
    <style>
        /* --- 色の定義 --- */
        :root {
            /* 主操作部分（濃いめの黄色） */
            --bg-panel-main: rgba(255, 230, 105, 0.95);
            /* サブ操作部分（薄い目の黄色） */
            --bg-panel-sub:  rgba(255, 250, 205, 0.95);
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            background-color: #f0f0f0; 
        }
        
        #container { 
            display: flex; 
            width: 100vw; 
            height: 100vh; 
        }

        #canvas-wrapper { 
            flex-grow: 1; 
            position: relative; 
            background: #ffffff; 
            overflow: hidden; 
            cursor: default; 
        }

        /* --- ラベル・注釈 --- */
        .dim-label, .handle-label, .l-label {
            position: absolute;
            pointer-events: none;
            white-space: nowrap;
            z-index: 20;
            opacity: 0; 
            transition: opacity 0.2s ease-out;
        }
        .dim-label, .l-label-val {
            background: var(--bg-panel-sub);
            padding: 4px 10px;
            border-radius: 4px;
            font-family: Consolas, monospace;
            font-size: 15px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            text-align: left;
        }
        .dim-label { border: 2px solid #2980b9; color: #2980b9; }
        .e-label { border-color: #27ae60; color: #27ae60; }
        .l-label-val { border: 2px solid #e67e22; color: #d35400; }

        /* 右上のコントロール群 */
        .top-right-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 10;
            display: flex;
            flex-direction: row; 
            gap: 10px;
            align-items: flex-start;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* 減衰パネル */
        #damping-control-panel {
            background: var(--bg-panel-main);
        }

        /* 表示系パネル */
        #display-control-panel {
            background: var(--bg-panel-sub);
        }

        .control-row {
            display: flex;
            align-items: center;
            white-space: nowrap;
            justify-content: space-between;
        }
        
        .control-row span { 
            margin-right: 10px; 
            font-weight: bold; 
            font-size: 13px;
            color: #2c3e50;
            width: 100px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .control-row input[type=range] { 
            width: 100px; 
            cursor: pointer; 
            vertical-align: middle;
        }
        .control-row input[type=range]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- 学習プリセットパネル --- */
        #preset-panel {
            position: absolute;
            top: 140px; 
            left: 15px;
            z-index: 10;
            background: var(--bg-panel-main); 
            padding: 8px 12px; 
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: fit-content; 
            border: 1px solid #bdc3c7;
        }

        .preset-header {
            font-size: 13px;
            font-weight: bold;
            color: #34495e;
            border-bottom: 2px solid #3498db;
            margin-bottom: 4px;
            padding-bottom: 2px;
        }

        .preset-row {
            display: flex;
            flex-direction: column;
            gap: 6px; 
            font-size: 12px; 
            color: #2c3e50;
            font-weight: bold;
        }
        .preset-row label {
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: color 0.2s;
        }
        .preset-row label:hover {
            color: #2980b9;
        }
        .preset-row input[type="radio"] {
            margin-right: 8px;
            transform: scale(1.1); 
            cursor: pointer;
            accent-color: #00bfff;
        }
        .preset-row input[type="radio"]:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .handle-label {
            background: #34495e;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 15;
        }
        .handle-label-right { transform: translate(10px, -50%); }
        .handle-label-right::after { content: ''; position: absolute; left: -5px; top: 50%; transform: translateY(-50%); border-width: 5px 5px 5px 0; border-style: solid; border-color: transparent #34495e transparent transparent; }
        .handle-label-left { transform: translate(-100%, -50%); margin-left: -10px; }
        .handle-label-left::after { content: ''; position: absolute; right: -5px; top: 50%; transform: translateY(-50%); border-width: 5px 0 5px 5px; border-style: solid; border-color: transparent transparent transparent #34495e; }


        /* --- UIパネル --- */
        .side-panel {
            width: 340px;
            flex-shrink: 0;
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 16px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            z-index: 10;
            user-select: none;
        }

        #left-panel { box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        #ui-panel { box-shadow: -2px 0 5px rgba(0,0,0,0.1); }

        h2 { font-size: 16px; font-weight: bold; border-bottom: 1px solid #7f8c8d; padding-bottom: 10px; margin: 0 0 10px; letter-spacing: 0.05em; }

        .mode-select-container {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            border: 1px solid #465f75;
        }
        .mode-select-label { font-size: 12px; color: #bdc3c7; display: block; margin-bottom: 4px; font-weight: bold;}
        #mode-selector {
            width: 100%;
            padding: 6px;
            font-size: 14px;
            border-radius: 4px;
            border: 1px solid #7f8c8d;
            background: #ecf0f1;
            color: #2c3e50;
            font-weight: bold;
            cursor: default; /* クリック不可 */
        }

        /* --- 解説ボタン周辺のレイアウト --- */
        .prerequisites-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
            border-bottom: 1px dashed #546e7a;
            padding-bottom: 5px;
        }
        .prerequisites {
            font-size: 11px;
            color: #bdc3c7;
            line-height: 1.4;
        }
        #btn-explanation {
            font-size: 11px;
            padding: 4px 8px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 8px;
            white-space: nowrap;
            box-shadow: 0 2px 0 #2980b9;
        }
        #btn-explanation:hover { background-color: #2980b9; }
        #btn-explanation:active { transform: translateY(2px); box-shadow: none; }


        .calc-block {
            background: rgba(52, 73, 94, 0.6);
            border: 1px solid #465f75;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        #impulse-panel {
            background: var(--bg-panel-main) !important;
            color: #2c3e50;
        }
        #impulse-panel .block-header {
            color: #2c3e50;
            border-bottom: 1px solid #7f8c8d;
        }
        #impulse-panel .control-row span, #impulse-panel div {
            color: #2c3e50 !important;
        }
        
        .block-header { 
            font-size: 14px; 
            font-weight: bold;
            color: #bdc3c7; 
            margin-bottom: 4px; 
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #btn-toggle-decomp {
            font-size: 11px;
            padding: 2px 6px;
            cursor: pointer;
            border: 1px solid #bdc3c7;
            border-radius: 3px;
            background: var(--bg-panel-main) !important;
            color: #000000 !important;
            font-weight: bold;
        }
        
        .flex-row { display: flex; justify-content: space-between; align-items: center; min-height: 32px; }
        .math-area { flex-grow: 1; display: flex; align-items: center; justify-content: flex-start; font-size: 14px; color: #ecf0f1; margin-right: 10px; }
        .fraction { display: inline-flex; flex-direction: column; align-items: center; margin: 0 4px; vertical-align: middle; font-size: 0.9em; }
        .numerator { border-bottom: 1px solid #ecf0f1; padding-bottom: 1px; margin-bottom: 1px; text-align: center; }
        .denominator { padding-top: 1px; text-align: center; }
        .result-area { text-align: right; font-weight: bold; font-size: 16px; white-space: nowrap; letter-spacing: 0.05em; }
        
        .val-green { color: #2ecc71; }
        .val-red { color: #e74c3c; }
        .val-orange { color: #f39c12; }
        .val-blue { color: #3498db; }
        .unit { font-size: 0.7em; color: #95a5a6; margin-left: 2px; font-weight: normal;}

        /* --- 振動制御ボタン群 --- */
        .control-btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-btn {
            flex: 1;
            padding: 10px 0;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }
        .control-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 rgba(0,0,0,0.2); }

        #btn-play-pause {
            background-color: #27ae60;
            box-shadow: 0 4px 0 #219150;
        }
        #btn-play-pause.running {
            background-color: #f39c12;
            box-shadow: 0 4px 0 #d35400;
        }
        #btn-play-pause.running:active { box-shadow: 0 2px 0 #d35400; }

        #btn-stop {
            background-color: #7f8c8d;
            box-shadow: 0 4px 0 #5f6a6b;
        }
        #btn-stop:hover { background-color: #c0392b; box-shadow: 0 4px 0 #962d22;}
        #btn-stop:active { box-shadow: 0 2px 0 #962d22; }


        /* --- グラフ・凡例レイアウト --- */
        .graph-container {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #465f75;
        }
        .graph-title {
            font-size: 15px;
            font-weight: bold;
            color: #bdc3c7;
            margin-bottom: 6px;
            text-align: center;
        }
        .graph-row {
            display: flex;
            align-items: center; 
            justify-content: space-between;
        }
        
        canvas.graph-canvas {
            display: block;
            background: #ffffff;
            border-radius: 4px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
            cursor: default;
        }
        
        canvas.scrubbable {
            cursor: ew-resize !important;
        }

        #schematic-canvas {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 30;
            pointer-events: none;
        }

        .legend-col {
            flex-shrink: 0;
            width: 90px;
            padding-left: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 13px;
            color: #ecf0f1;
            line-height: 1.2;
        }
        
        .legend-mark {
            width: 12px;
            height: 12px;
            margin-right: 6px;
            flex-shrink: 0;
        }
        
        .mark-circle { border-radius: 50%; border: 1px solid rgba(255,255,255,0.3); }
        .bg-blue { background-color: #3498db; }
        .bg-green { background-color: #27ae60; }
        .bg-red { background-color: #e74c3c; }
        
        .mark-square { border-radius: 2px; }
        .bg-blue-area { background-color: rgba(52, 152, 219, 0.6); border: 1px solid #3498db; }
        .bg-red-area { background-color: rgba(231, 76, 60, 0.6); border: 1px solid #e74c3c; }
        .bg-yellow-area { background-color: rgba(241, 196, 15, 0.6); border: 1px solid #f39c12; }

        .sub-text { font-size: 11px; color: #95a5a6; display: block; margin-top: 1px;}
        .line-mark { width: 14px; height: 2px; background-color: #e67e22; margin-right: 6px; }
        .graph-note { font-size: 11px; color: #95a5a6; text-align: center; margin-top: 4px; }
        .legend-note { font-size: 11px; color: #95a5a6; margin-top: 8px; }

        /* --- 解説モーダル --- */
        #explanation-modal {
            display: none; /* デフォルト非表示 */
            position: absolute; /* Body直下なので画面全体に対する絶対配置 */
            /* 初期位置はJSで制御しますが、CSSでも中央寄せしておく */
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            
            width: 600px;
            height: 400px;
            min-width: 300px;
            min-height: 200px;
            
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            
            /* 最前面に表示 */
            z-index: 10000; 
            
            flex-direction: column;
            resize: both; /* CSSリサイズ */
            overflow: hidden; 
            border: 1px solid #bdc3c7;
        }

        #modal-header {
            padding: 10px 15px;
            background: #2c3e50;
            color: white;
            font-weight: bold;
            cursor: move; /* ドラッグ可能を示すカーソル */
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        #btn-modal-close {
            background: transparent;
            border: none;
            color: #ecf0f1;
            font-size: 20px;
            cursor: pointer;
            line-height: 1;
        }
        #btn-modal-close:hover { color: #e74c3c; }

        #modal-content {
            padding: 15px;
            overflow-y: auto; /* 縦スクロール */
            flex-grow: 1;
            font-size: 14px;
            color: #333;
            line-height: 1.6;
        }
        #modal-content h3 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 16px;
            color: #2c3e50;
        }
        #modal-content p {
            margin-bottom: 10px;
        }

    </style>
    
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

<div id="container">
    
    <div id="left-panel" class="side-panel">
        <h2>物理量モニタリング</h2>
        
        <div class="graph-container">
            <div class="graph-title">F-x 線図 (履歴軌跡)</div>
            <div class="graph-row">
                <canvas id="force-graph-canvas" class="graph-canvas" width="220" height="220"></canvas>
                
                <div class="legend-col">
                    <div class="legend-item">
                        <span class="legend-mark mark-circle bg-blue"></span>
                        <div id="legend-blue-label">
                            復元力＋減衰力<span class="sub-text">F_int</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="graph-note">
                ※グラフ範囲：自動オートスケール(F基準)
            </div>
        </div>

        <div class="graph-container">
            <div class="graph-title">変位-時間 (t-x)</div>
            <div class="graph-row">
                <canvas id="time-graph-canvas" class="graph-canvas" width="220" height="160"></canvas>
                
                <div class="legend-col">
                    <div class="legend-item">
                        <span class="line-mark"></span>
                        <div>変位<span class="sub-text">Disp. x</span></div>
                    </div>
                    <div class="legend-note">
                        横軸：時間 t<br>
                        縦軸：変位 x<br>
                        (0.5秒間を表示)
                    </div>
                </div>
            </div>
        </div>

        <div class="graph-container" style="border-bottom:none;">
            <div class="graph-title">エネルギー推移 (t-E)</div>
            <div class="graph-row">
                <canvas id="energy-graph-canvas" class="graph-canvas" width="220" height="160"></canvas>
                
                <div class="legend-col">
                    <div class="legend-item">
                        <span class="legend-mark mark-square bg-red-area"></span>
                        <div>運動E<span class="sub-text">Kinetic</span></div>
                    </div>
                    <div class="legend-item">
                        <span class="legend-mark mark-square bg-blue-area"></span>
                        <div>位置E<span class="sub-text">Potential</span></div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <div id="canvas-wrapper">
        <canvas id="schematic-canvas" width="160" height="110"></canvas>
        
        <div id="preset-panel">
            <div class="preset-header">学習プリセット</div>
            <div class="preset-row">
                <label><input type="radio" name="preset-mode" value="none" checked> ① 無指定</label>
                <label><input type="radio" name="preset-mode" value="beats"> ② うなり (h=0.05, 間隔=0.8)</label>
                <label><input type="radio" name="preset-mode" value="resonance"> ③ 共振 (h=0, 間隔=1.0)</label>
                <label><input type="radio" name="preset-mode" value="antiphase"> ④ 逆位相 (h=0, 間隔=0.5)</label>
                <label><input type="radio" name="preset-mode" value="damping"> ⑤ 減衰効果 (h=0.2, 間隔=1.0)</label>
                <label><input type="radio" name="preset-mode" value="random"> ⑥ ランダム</label>
            </div>
        </div>

        <div class="top-right-controls">
            <div class="control-panel" id="damping-control-panel">
                <div class="control-row">
                    <span id="damping-slider-label">減衰 h: 0.05</span>
                    <input type="range" id="damping-slider" min="0.00" max="0.3" step="0.01" value="0.05">
                </div>
            </div>

            <div class="control-panel" id="display-control-panel">
                <div class="control-row">
                    <span id="exag-label">変形誇張: 100x</span>
                    <input type="range" id="exag-slider" min="0" max="200" step="1" value="100">
                </div>
                <div class="control-row">
                    <span id="speed-label">再生速度: 0.1x</span>
                    <input type="range" id="speed-slider" min="0.1" max="2.0" step="0.1" value="0.1">
                </div>
            </div>
        </div>

        <div id="label-a" class="dim-label">a</div>
        <div id="label-b" class="dim-label">b</div>
        <div id="label-E" class="dim-label e-label">E</div>
        <div id="label-L" class="l-label l-label-val">L</div>
        
        <div id="label-handle" class="handle-label handle-label-right">断面寸法変更ハンドル</div>
        <div id="label-handle-e" class="handle-label handle-label-left">ヤング係数変更ハンドル</div>
        <div id="label-handle-l" class="handle-label handle-label-left">長さ変更ハンドル</div>
    
    </div>

    <div id="ui-panel" class="side-panel">
        
        <div class="mode-select-container" style="visibility: hidden;">
            <span class="mode-select-label">シミュレーションモード</span>
            <select id="mode-selector" disabled style="opacity:1; color:#2c3e50; font-weight:bold;">
                <option value="forced" selected>３．１質点系強制振動（調和振動）</option>
            </select>
        </div>

        <div class="prerequisites-container">
            <div class="prerequisites">
                前提条件：ポアソン比 ν=0.2, 形状係数 κ=1.2<br>
                コンクリート密度 ρ=2.4 t/m³<br>
                <span id="damping-note" style="color:#f1c40f;">※インパルス応答（自由振動の重ね合わせ）</span>
            </div>
            <button id="btn-explanation">解説</button>
        </div>

        <div class="control-btn-group">
            <button id="btn-play-pause" class="control-btn">振動開始 (Start)</button>
            <button id="btn-stop" class="control-btn">停止 (Reset)</button>
        </div>

        <div class="calc-block" id="impulse-panel">
            <div class="block-header">
                <span>外力入力 (インパルス列)</span>
            </div>
            <canvas id="impulse-canvas" width="300" height="160" style="width:100%; height:160px; background:#fff; border-radius:4px; cursor:pointer; touch-action:none;"></canvas>
            <div class="control-row" style="margin-top:8px;">
                <span id="impulse-label-text" style="font-size:11px; width:auto; margin-right:5px; color:#2c3e50;">インパルス間隔: 1.00×Tn (0.00秒)</span>
                <input type="range" id="impulse-interval-slider" min="0.5" max="1.5" step="0.05" value="1.0" style="width:120px;">
            </div>
        </div>

        <div class="calc-block" id="decomposition-panel" style="background: rgba(44, 62, 80, 0.8);">
            <div class="block-header">
                <span>応答波形の成分分解</span>
                <button id="btn-toggle-decomp">▼ 展開</button>
            </div>
            <canvas id="decomposition-canvas" width="300" height="160" style="width:100%; height:160px; background:#fff; border-radius:4px; cursor:default;"></canvas>
            <div style="font-size:10px; color:#bdc3c7; text-align:right; margin-top:4px;">
                細線: 成分応答 / 太線: 合成応答
            </div>
        </div>

        <div class="calc-block">
            <div class="block-header">
                <span>断面二次モーメント (I)</span>
            </div>
            <div class="flex-row">
                <div class="math-area">
                    <span>I = </span>
                    <div class="fraction">
                        <span class="numerator">b · a<sup>3</sup></span>
                        <span class="denominator">12</span>
                    </div>
                </div>
                <div class="result-area val-green">
                    <span id="res-val-I">0.000</span><span class="unit">m⁴</span>
                </div>
            </div>
        </div>

        <div class="calc-block">
            <div class="block-header">
                <span>固有周期 (Tn)</span>
            </div>
            <div class="flex-row">
                <div class="math-area">
                    <span>Tn = 2π</span>
                    <span style="font-size:1.2em; margin:0 2px;">√</span>
                    <div class="fraction">
                        <span class="numerator">m</span>
                        <span class="denominator">k</span>
                    </div>
                </div>
                <div class="result-area val-orange">
                    <span id="res-val-T">0.000</span><span class="unit">sec</span>
                </div>
            </div>
        </div>

        <div class="calc-block">
            <div class="block-header">
                <span>変形量 (δ)</span>
            </div>
            <div class="flex-row">
                <div class="math-area">
                    <span>δ = δ<sub>b</sub> + δ<sub>s</sub></span>
                </div>
                <div class="result-area val-red" style="font-size:22px;">
                    <span id="res-val-total">0.000</span><span class="unit">m</span>
                </div>
            </div>
        </div>

        <div class="calc-block">
            <div class="block-header">
                <span>合計変形角 (θ)</span>
            </div>
            <div class="flex-row">
                <div class="math-area">
                    <span>θ (層間変形角)</span>
                </div>
                <div class="result-area val-blue" style="font-size:15px;">
                    <span id="res-val-theta">0.0000 rad</span>
                </div>
            </div>
        </div>

        <input type="checkbox" id="toggle-bending" checked style="display:none;">
        <input type="checkbox" id="toggle-shear" checked style="display:none;">

    </div>
</div>

<div id="explanation-modal">
    <div id="modal-header">
        <span id="modal-title">解説ウィンドウ</span>
        <button id="btn-modal-close">×</button>
    </div>
    <div id="modal-content">
        <p>読み込み中...</p>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';

    // --- 初期化 ---
    const canvasWrapper = document.getElementById('canvas-wrapper');
    let width = canvasWrapper.clientWidth;
    let height = canvasWrapper.clientHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const frustumSize = 20; 
    let aspect = width / height;
    const camera = new THREE.OrthographicCamera(
        frustumSize * aspect / -2, frustumSize * aspect / 2,
        frustumSize / 2, frustumSize / -2,
        1, 1000
    );
    camera.position.set(0, -100, 6); 
    camera.lookAt(0, 0, 3);          
    camera.up.set(0, 0, 1);          

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    canvasWrapper.appendChild(renderer.domElement);

    // ★修正：変形誇張のデフォルト値を100に★
    let visualExaggeration = 100.0;
    
    const SEGMENTS = 60; 
    const SECTION_Z_POS = -3.0;
    const NU = 0.2; 
    const KAPPA = 1.2; 
    const RHO_CONC = 2.4; 
    
    // ★物理計算用の定数: インパルスの作用時間(秒) 0.01秒★
    const IMPULSE_DURATION = 0.01; 

    // --- 3Dオブジェクト構築 ---
    const groundGroup = new THREE.Group();
    groundGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-8,0,0), new THREE.Vector3(8,0,0)]), new THREE.LineBasicMaterial({color:0x000000, linewidth:2})));
    const hatchPoints = []; for(let x=-8; x<=8; x+=0.5) hatchPoints.push(x,0,0, x-0.4,0,-0.6);
    groundGroup.add(new THREE.LineSegments(new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(hatchPoints,3)), new THREE.LineBasicMaterial({color:0x000000})));
    scene.add(groundGroup);

    const colGeo = new THREE.BufferGeometry();
    const colPos = new Float32Array((SEGMENTS+1)*2*3);
    const colIndices = []; for(let i=0;i<SEGMENTS;i++) colIndices.push(i*2, i*2+1, (i+1)*2, i*2+1, (i+1)*2+1, (i+1)*2);
    colGeo.setAttribute('position', new THREE.BufferAttribute(colPos, 3)); colGeo.setIndex(colIndices);
    const columnMesh = new THREE.Mesh(colGeo, new THREE.MeshBasicMaterial({ color: 0x95a5a6, side: THREE.DoubleSide, transparent: true, opacity: 0.6 }));
    scene.add(columnMesh);
    const columnWire = new THREE.LineSegments(new THREE.EdgesGeometry(colGeo), new THREE.LineBasicMaterial({ color: 0x7f8c8d, linewidth: 2 }));
    columnMesh.add(columnWire);
    const redLines = new THREE.LineSegments(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(9*2*3), 3)), new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }));
    scene.add(redLines);

    const sectionGroup = new THREE.Group();
    sectionGroup.position.set(0, 0, SECTION_Z_POS);
    sectionGroup.rotation.x = -Math.PI / 2;
    scene.add(sectionGroup);
    const rectGeo = new THREE.PlaneGeometry(1, 1);
    const sectionRect = new THREE.Mesh(rectGeo, new THREE.MeshBasicMaterial({ color: 0x95a5a6, side: THREE.DoubleSide, transparent: true, opacity: 0.3 }));
    sectionGroup.add(sectionRect);
    sectionRect.add(new THREE.LineSegments(new THREE.EdgesGeometry(rectGeo), new THREE.LineBasicMaterial({ color: 0x7f8c8d }))); 
    const hatchLineGeo = new THREE.BufferGeometry();
    hatchLineGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(1200), 3));
    const sectionHatch = new THREE.LineSegments(hatchLineGeo, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5 }));
    sectionGroup.add(sectionHatch); 

    const gizmoGroup = new THREE.Group(); gizmoGroup.position.set(0, -0.1, SECTION_Z_POS); scene.add(gizmoGroup);
    const handleMat = new THREE.MeshBasicMaterial({ color: 0x2980b9, side: THREE.DoubleSide });
    const hoverColor = 0x3498db; const BAR_THICKNESS = 0.08; const BAR_LENGTH = 0.6;
    function createBoxHandle(w, h, axis) {
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), handleMat.clone()); mesh.rotation.x = -Math.PI / 2;
        const hit = new THREE.Mesh(new THREE.PlaneGeometry(Math.max(w,0.5), Math.max(h,0.5)), new THREE.MeshBasicMaterial({visible:false}));
        hit.rotation.x = -Math.PI / 2; hit.add(mesh); hit.userData = { axis: axis, isHandle: true, type: 'dim', visual: mesh };
        return hit;
    }
    const hitRight = createBoxHandle(BAR_THICKNESS, BAR_LENGTH, 'a'); gizmoGroup.add(hitRight);
    const hitTop = createBoxHandle(BAR_LENGTH, BAR_THICKNESS, 'b'); gizmoGroup.add(hitTop);
    const cornerContainer = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), new THREE.MeshBasicMaterial({visible:false}));
    cornerContainer.rotation.x = -Math.PI/2;
    const cornerVisual = new THREE.Mesh(new THREE.CircleGeometry(0.15, 32), handleMat.clone());
    cornerContainer.add(cornerVisual); cornerContainer.userData = { axis: 'both', isHandle: true, type: 'dim', visual: cornerVisual }; gizmoGroup.add(cornerContainer);
    
    const eVisual = new THREE.Mesh(new THREE.CircleGeometry(0.15, 32), new THREE.MeshBasicMaterial({ color: 0x27ae60, side: THREE.DoubleSide }));
    const eHit = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.5), new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide }));
    eHit.rotation.x = -Math.PI / 2; eHit.add(eVisual); eHit.userData = { isHandle: true, type: 'E', visual: eVisual }; gizmoGroup.add(eHit);
    
    const anchorTR = new THREE.Object3D(); gizmoGroup.add(anchorTR); 
    const anchorBL = new THREE.Object3D(); gizmoGroup.add(anchorBL); 

    const lVisual = new THREE.Mesh(new THREE.SphereGeometry(0.18, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffa500 }));
    const lHit = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.6), new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide }));
    lHit.add(lVisual); lHit.userData = { isHandle: true, type: 'L', visual: lVisual }; scene.add(lHit);

    const interactables = [hitRight, hitTop, cornerContainer, eHit, lHit];

    // --- State & UI Logic ---
    const state = { P0: 5.0, E: 20.5, a: 0.5, b: 0.5, L: 4.0, mode: 'forced', h: 0.05 };
    const animState = { isRunning: false, time: 0.0, speed: 0.1 };
    
    // ★ インパルス入力の状態 ★
    const impulseState = {
        intervalRatio: 1.0, 
        magnitudes: [1.0, 0.5, 0.0, 0.0, 0.0], 
        colors: ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'],
        Pmax: 100.0 
    };

    // --- ★ 3D Arrow Visualization (1/4 Scale, Thicker) Setup ---
    const impulseArrows = [];
    
    function createArrow(colorHex) {
        const group = new THREE.Group();
        const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 1.0 });

        // ★修正箇所：ここでの数値を変更して太さを調整します
        
        // 矢羽根（Head）の設定
        const headH = 0.24; // 矢羽根の長さ（少し長く 0.125 -> 0.24）
        const headR = 0.2; // 矢羽根の太さ（倍増 0.05 -> 0.2）
        
        const headGeo = new THREE.ConeGeometry(headR, headH, 16);
        headGeo.rotateZ(-Math.PI / 2); 
        headGeo.translate(-headH / 2, 0, 0); 
        const head = new THREE.Mesh(headGeo, mat);

        // 竿（Shaft）の設定
        // 全長を約0.5mに保つため、竿の長さは (0.5 - headH) で調整
        const totalLen = 0.5;
        const shaftH = totalLen - headH; 
        const shaftR = 0.1; // 竿の太さ（3倍 0.02 -> 0.1）
        
        const shaftGeo = new THREE.CylinderGeometry(shaftR, shaftR, shaftH, 12);
        shaftGeo.rotateZ(-Math.PI / 2);
        shaftGeo.translate(-headH - (shaftH / 2), 0, 0);
        const shaft = new THREE.Mesh(shaftGeo, mat);

        group.add(head);
        group.add(shaft);
        group.visible = false;
        scene.add(group);
        return group;
    }

    // Create 5 arrows
    impulseState.colors.forEach(col => {
        impulseArrows.push(createArrow(col));
    });


    const clock = new THREE.Clock();
    
    let waveHistory = [];
    let isGraphScrubbing = false;
    let scrubStartMouseX = 0;
    
    // ★ 展開状態のフラグ ★
    let isDecompExpanded = false;

    const ui = { 
        resI: document.getElementById('res-val-I'),
        resTotal: document.getElementById('res-val-total'),
        resTheta: document.getElementById('res-val-theta'),
        resT: document.getElementById('res-val-T'),
        
        labelA: document.getElementById('label-a'), labelB: document.getElementById('label-b'), 
        labelE: document.getElementById('label-E'), 
        labelL: document.getElementById('label-L'),
        labelHandle: document.getElementById('label-handle'), labelHandleE: document.getElementById('label-handle-e'), 
        labelHandleL: document.getElementById('label-handle-l'),
        
        toggleBending: document.getElementById('toggle-bending'),
        toggleShear: document.getElementById('toggle-shear'),
        
        btnPlayPause: document.getElementById('btn-play-pause'),
        btnStop: document.getElementById('btn-stop'),
        
        speedSlider: document.getElementById('speed-slider'),
        speedLabel: document.getElementById('speed-label'),
        
        exagSlider: document.getElementById('exag-slider'),
        exagLabel: document.getElementById('exag-label'),
        
        dampingPanel: document.getElementById('damping-control-panel'),
        dampingSlider: document.getElementById('damping-slider'),
        dampingLabel: document.getElementById('damping-slider-label'),
        
        legendBlueLabel: document.getElementById('legend-blue-label'),

        graphCanvas: document.getElementById('force-graph-canvas'),
        timeCanvas: document.getElementById('time-graph-canvas'),
        energyCanvas: document.getElementById('energy-graph-canvas'),
        schematicCanvas: document.getElementById('schematic-canvas'),

        // 新しいUI要素
        impulseCanvas: document.getElementById('impulse-canvas'),
        impulseIntervalSlider: document.getElementById('impulse-interval-slider'),
        impulseLabelText: document.getElementById('impulse-label-text'),
        
        decompCanvas: document.getElementById('decomposition-canvas'),
        btnToggleDecomp: document.getElementById('btn-toggle-decomp'),
        
        // ★学習プリセット用★
        presetRadios: document.getElementsByName('preset-mode'),
        
        // ★解説ボタン★
        btnExplanation: document.getElementById('btn-explanation'),
        modal: document.getElementById('explanation-modal'),
        btnCloseModal: document.getElementById('btn-modal-close'),
        modalHeader: document.getElementById('modal-header'),
        modalContent: document.getElementById('modal-content')
    };

    // --- 解説モーダルの制御 ---
    if(ui.btnExplanation) {
        // ドラッグ用変数
        let isDraggingModal = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // 開く
        ui.btnExplanation.addEventListener('click', () => {
            ui.modal.style.display = 'flex';
            
            // 中央配置リセット (transformを解除してtop/leftで固定する)
            const rect = ui.modal.getBoundingClientRect();
            // 画面中央になるようにtop/leftを設定
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            ui.modal.style.transform = 'none'; // transform中央揃えを解除
            ui.modal.style.left = (winW/2 - rect.width/2) + 'px';
            ui.modal.style.top = (winH/2 - rect.height/2) + 'px';

            loadExplanation();
        });

        // 閉じる
        ui.btnCloseModal.addEventListener('click', () => {
            ui.modal.style.display = 'none';
        });

        // ドラッグ開始
        ui.modalHeader.addEventListener('mousedown', (e) => {
            isDraggingModal = true;
            // Ensure transform is gone so offsetting works linearly
            if(getComputedStyle(ui.modal).transform !== 'none') {
                 ui.modal.style.transform = 'none';
            }
            
            const rect = ui.modal.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            ui.modalHeader.style.cursor = 'grabbing';
        });

        // ドラッグ中
        window.addEventListener('mousemove', (e) => {
            if (!isDraggingModal) return;
            
            // 仮の計算位置
            let x = e.clientX - dragOffsetX;
            let y = e.clientY - dragOffsetY;

            // 画面端の制限
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const modalW = ui.modal.offsetWidth;
            const modalH = ui.modal.offsetHeight;

            // 左端・右端のチェック
            if (x < 0) x = 0;
            else if (x + modalW > winW) x = winW - modalW;

            // 上端・下端のチェック
            if (y < 0) y = 0;
            else if (y + modalH > winH) y = winH - modalH;

            ui.modal.style.left = x + 'px';
            ui.modal.style.top = y + 'px';
        });

        // ドラッグ終了
        window.addEventListener('mouseup', () => {
            isDraggingModal = false;
            if(ui.modalHeader) ui.modalHeader.style.cursor = 'move';
        });

        // JSON読み込み
        function loadExplanation() {
            ui.modalContent.innerHTML = '<p>読み込み中...</p>';
            
            fetch('explanation_impulse.json')
                .then(res => {
                    if (!res.ok) throw new Error("File not found");
                    return res.json();
                })
                .then(data => {
                    let html = `<h3>${data.title}</h3>`;
                    html += data.content;
                    ui.modalContent.innerHTML = html;
                    
                    // ★追加: コンテンツ挿入後に数式をレンダリング
                    if (window.MathJax) {
                        MathJax.typesetPromise([ui.modalContent]);
                    }
                })
                .catch(err => {
                    // フォールバック（ファイルがない場合）
                    // ★ここに数式入りの解説を記述します
                    ui.modalContent.innerHTML = `
                        <h3>インパルス応答の解説</h3>
                        <p>このシミュレーションは、線形系における重ね合わせの理を利用しています。</p>
                        
                        <p><b>運動方程式とインパルス応答：</b><br>
                        任意の時刻 $t$ における変位 $x(t)$ は、個々の衝撃入力による自由振動の総和（畳み込み）で表されます。</p>
                        
                        <div style="background:#f9f9f9; padding:10px; border-radius:4px; text-align:center;">
                            $$ x(t) = \\sum_{i=1}^{N} \\frac{P_i \\Delta t}{m \\omega_d} e^{-h \\omega_n (t - t_i)} \\sin(\\omega_d (t - t_i)) $$
                        </div>

                        <p>ここで、積分形式（デュアメルの積分）で表すと以下のようになります。</p>
                         <div style="background:#f9f9f9; padding:10px; border-radius:4px; text-align:center;">
                            $$ x(t) = \\frac{1}{m \\omega_d} \\int_0^t F(\\tau) e^{-h \\omega_n (t - \\tau)} \\sin \\omega_d(t - \\tau) d\\tau $$
                        </div>

                        <p><b>主な現象：</b><br>
                        <ul>
                            <li><b>共振 ($T \\approx T_n$):</b> 加振周期が固有周期と一致すると、位相が揃い振幅が増大します。</li>
                            <li><b>うなり ($T \\approx T_n$):</b> わずかに周期がずれると振幅の増減を繰り返します。</li>
                        </ul>
                        </p>
                    `;

                    // ★追加: フォールバック表示後にも数式レンダリングを実行
                    if (window.MathJax) {
                        MathJax.typesetPromise([ui.modalContent]);
                    }
                });
        }
    }


    const graphCtx = ui.graphCanvas.getContext('2d');
    const timeCtx = ui.timeCanvas.getContext('2d'); 
    const energyCtx = ui.energyCanvas.getContext('2d');
    const schematicCtx = ui.schematicCanvas.getContext('2d');
    const impulseCtx = ui.impulseCanvas.getContext('2d');
    const decompCtx = ui.decompCanvas.getContext('2d');

    const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
    let isDragging = false; let activeHandle = null; let dragStartVal = 0; let dragStartMouse = { x: 0, y: 0 };

    function toInverseFraction(val) {
        if (!val || Math.abs(val) < 0.0000001) return "0";
        const denom = Math.round(1 / val);
        if (denom === 0) return "1/0 (Error)"; 
        return `1/${denom}`;
    }

    ui.dampingSlider.addEventListener('input', (e) => {
        state.h = parseFloat(e.target.value);
        ui.dampingLabel.innerText = `減衰 h: ${state.h.toFixed(2)}`;
        if (!animState.isRunning) update();
    });

    ui.speedSlider.addEventListener('input', (e) => {
        animState.speed = parseFloat(e.target.value);
        ui.speedLabel.innerText = `再生速度: ${animState.speed.toFixed(1)}x`;
    });
    
    ui.exagSlider.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        let realExag;
        if (val <= 100) {
            let raw = 1 + (val / 100.0) * 99;
            if(val === 0) realExag = 1;
            else realExag = Math.round(raw / 10) * 10;
            if(realExag < 1) realExag = 1;
        } else {
            let raw = 100 + ((val - 100) / 100.0) * 900;
            realExag = Math.round(raw / 100) * 100;
        }
        visualExaggeration = realExag;
        ui.exagLabel.innerText = `変形誇張: ${visualExaggeration}x`;
        if(!animState.isRunning) update(); 
    });

    // ★ 外力UIのイベントリスナー設定 ★
    ui.impulseIntervalSlider.addEventListener('input', (e) => {
        impulseState.intervalRatio = parseFloat(e.target.value);
        if (!animState.isRunning) update();
    });
    
    // ★ 展開ボタンのイベントリスナー（修正：高さを480pxに） ★
    ui.btnToggleDecomp.addEventListener('click', () => {
        isDecompExpanded = !isDecompExpanded;
        if(isDecompExpanded) {
            ui.btnToggleDecomp.innerText = "▲ 畳む";
            // 600px * 0.8 = 480px
            ui.decompCanvas.height = 480; 
            ui.decompCanvas.style.height = "480px";
        } else {
            ui.btnToggleDecomp.innerText = "▼ 展開";
            ui.decompCanvas.height = 160;
            ui.decompCanvas.style.height = "160px";
        }
        if(!animState.isRunning) update();
    });

    // --- ★学習プリセットロジック★ ---
    function applyPreset(mode) {
        // "none" の場合はロック解除のみ
        if (mode === 'none') {
            ui.dampingSlider.disabled = false;
            ui.impulseIntervalSlider.disabled = false;
            
            // ★デフォルト設定に戻す（100倍）
            visualExaggeration = 100.0;
            ui.exagSlider.value = 100;
            ui.exagLabel.innerText = `変形誇張: ${visualExaggeration}x`;
            
            if (!animState.isRunning) update();
            return;
        }

        // それ以外はパラメータを固定してロック
        // (ランダムモードの場合はロックしないので、ここではモード判定が必要)
        let isRandom = (mode === 'random');
        if (!isRandom) {
            ui.dampingSlider.disabled = true;
            ui.impulseIntervalSlider.disabled = true;
        }

        let targetH = state.h;
        let targetInterval = impulseState.intervalRatio;
        let targetMags = [...impulseState.magnitudes]; 
        let targetExag = 100.0; // 基本は100倍

        switch(mode) {
            case 'beats': // うなり
                targetH = 0.05; 
                targetInterval = 0.80;
                targetMags = [1.0, 1.0, 1.0, 1.0, 1.0];
                targetExag = 100.0;
                break;
            case 'resonance': // 共振
                targetH = 0.00; 
                targetInterval = 1.00;
                targetMags = [1.0, 1.0, 1.0, 1.0, 1.0];
                targetExag = 20.0; // ★共振時は20倍
                break;
            case 'antiphase': // 逆位相
                targetH = 0.00; 
                targetInterval = 0.50;
                targetMags = [1.0, 1.0, 0.0, 0.0, 0.0];
                targetExag = 100.0;
                break;
            case 'damping': // 減衰効果
                targetH = 0.20; 
                targetInterval = 1.00;
                targetMags = [1.0, 1.0, 1.0, 1.0, 1.0];
                targetExag = 100.0;
                break;
            
            case 'random': // ランダムジェネレーター
                // 1. 減衰 h: 0.00 ~ 0.10 (step 0.01)
                targetH = Math.floor(Math.random() * 11) / 100;

                // 2. 間隔: 0.50 ~ 1.50 (step 0.05)
                targetInterval = 0.5 + Math.floor(Math.random() * 21) * 0.05;

                // 3. 荷重 P1~P5: 0.0 ~ 1.0 (step 0.1)
                // メリハリをつけるため、Maxが0.5未満なら1つを強制的に0.8以上にする
                targetMags = [];
                let maxVal = 0;
                for(let i=0; i<5; i++) {
                    let val = Math.floor(Math.random() * 11) / 10; 
                    targetMags.push(val);
                    if(val > maxVal) maxVal = val;
                }
                if (maxVal < 0.5) {
                    const luckyIdx = Math.floor(Math.random() * 5);
                    targetMags[luckyIdx] = 0.8 + Math.floor(Math.random() * 3) / 10; 
                }
                targetExag = 100.0;
                break;
        }

        // 値の適用
        state.h = targetH;
        impulseState.intervalRatio = targetInterval;
        impulseState.magnitudes = targetMags;
        visualExaggeration = targetExag;

        // UIへの反映
        ui.dampingSlider.value = targetH;
        ui.dampingLabel.innerText = `減衰 h: ${state.h.toFixed(2)}`;
        ui.impulseIntervalSlider.value = targetInterval;
        
        ui.exagSlider.value = targetExag;
        ui.exagLabel.innerText = `変形誇張: ${visualExaggeration}x`;
        
        // ランダムモードの場合は、即座に「無指定」に戻してロック解除
        if (isRandom) {
            ui.presetRadios[0].checked = true;
            ui.dampingSlider.disabled = false;
            ui.impulseIntervalSlider.disabled = false;
        }

        // 再描画
        if (!animState.isRunning) update();
    }

    // ラジオボタンの変更イベント登録
    for(const radio of ui.presetRadios) {
        radio.addEventListener('change', (e) => {
            if(e.target.checked) applyPreset(e.target.value);
        });
    }

    let activeImpulseIndex = -1;
    
    // UI Constants
    const GRAPH_MARGIN_L = 35; 
    const GRAPH_MARGIN_B = 50;

    ui.impulseCanvas.addEventListener('pointerdown', (e) => {
        // ★ロック機能：プリセット選択中はグラフ操作不可
        if(!ui.presetRadios[0].checked) return;

        const rect = ui.impulseCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const x = mouseX - GRAPH_MARGIN_L;
        if (x < 0) return;
        
        const W = ui.impulseCanvas.width;
        const drawW = W - GRAPH_MARGIN_L - 15; 
        const totalScale = impulseState.intervalRatio * 6.0;
        
        let closestIdx = -1;
        let minDist = 1000;

        for(let i=0; i<5; i++) {
            const timeRatio = (i + 1) * impulseState.intervalRatio; 
            const barX = (timeRatio / totalScale) * drawW;
            const dist = Math.abs(x - barX);
            
            if(dist < 20) { 
                if(dist < minDist) {
                    minDist = dist;
                    closestIdx = i;
                }
            }
        }

        if(closestIdx !== -1) {
            activeImpulseIndex = closestIdx;
            updateImpulseFromMouse(e.clientY, rect);
            ui.impulseCanvas.setPointerCapture(e.pointerId);
            update();
        }
    });

    ui.impulseCanvas.addEventListener('pointermove', (e) => {
        const rect = ui.impulseCanvas.getBoundingClientRect();
        
        if(activeImpulseIndex !== -1) {
            updateImpulseFromMouse(e.clientY, rect);
            update();
        } else {
            // ロック中はカーソル変更もしない
            if(!ui.presetRadios[0].checked) {
                ui.impulseCanvas.style.cursor = 'default';
                return;
            }

            const mouseX = e.clientX - rect.left;
            const x = mouseX - GRAPH_MARGIN_L;
            const W = ui.impulseCanvas.width;
            const drawW = W - GRAPH_MARGIN_L - 15;
            const totalScale = impulseState.intervalRatio * 6.0;

            let onBar = false;
            for(let i=0; i<5; i++) {
                const timeRatio = (i + 1) * impulseState.intervalRatio; 
                const barX = (timeRatio / totalScale) * drawW;
                if(x >= 0 && Math.abs(x - barX) < 15) onBar = true;
            }
            ui.impulseCanvas.style.cursor = onBar ? 'ns-resize' : 'default';
        }
    });

    ui.impulseCanvas.addEventListener('pointerup', (e) => {
        activeImpulseIndex = -1;
        ui.impulseCanvas.releasePointerCapture(e.pointerId);
    });

    function updateImpulseFromMouse(clientY, rect) {
        const h = ui.impulseCanvas.height;
        const topMargin = 30; 
        const drawH = h - GRAPH_MARGIN_B - topMargin; 
        const originY = h - GRAPH_MARGIN_B;
        const y = clientY - rect.top;
        
        let val = (originY - y) / drawH;
        if(val < 0) val = 0;
        if(val > 1) val = 1;
        impulseState.magnitudes[activeImpulseIndex] = val;
    }


    ui.btnPlayPause.addEventListener('click', () => {
        if (animState.time === 0 && !animState.isRunning) {
            let changed = false;
            if (!ui.toggleBending.checked) { ui.toggleBending.checked = true; changed = true; }
            if (!ui.toggleShear.checked) { ui.toggleShear.checked = true; changed = true; }
            if (changed) handleToggleChange();

            ui.dampingSlider.disabled = true; 
            ui.impulseIntervalSlider.disabled = true; 
            // 実行中はプリセット変更もロック
            for(const r of ui.presetRadios) r.disabled = true;
        }

        animState.isRunning = !animState.isRunning;
        if(animState.isRunning) {
            ui.btnPlayPause.innerText = "一時停止 (Pause)";
            ui.btnPlayPause.classList.add('running');
            clock.start();
            if (animState.time === 0) {
                const initRes = calculateDisplacement(0);
                const F_int_init = initRes.stiffness * initRes.x;
                waveHistory = [{ t: 0, x: initRes.x, v: initRes.v, p: 0, f: F_int_init }];
            }
            ui.timeCanvas.classList.remove('scrubbable');
            ui.energyCanvas.classList.remove('scrubbable');
            // animate loop is already running via requestAnimationFrame
        } else {
            ui.btnPlayPause.innerText = "再開 (Resume)";
            ui.btnPlayPause.classList.remove('running');
            clock.stop();
            ui.timeCanvas.classList.add('scrubbable');
            ui.energyCanvas.classList.add('scrubbable');
            update();
        }
    });

    ui.btnStop.addEventListener('click', () => {
        animState.isRunning = false;
        animState.time = 0; 
        waveHistory = [];   
        clock.stop();
        ui.btnPlayPause.innerText = "振動開始 (Start)";
        ui.btnPlayPause.classList.remove('running');
        ui.timeCanvas.classList.remove('scrubbable');
        ui.energyCanvas.classList.remove('scrubbable');

        // 停止時はプリセット選択を有効化
        for(const r of ui.presetRadios) r.disabled = false;

        // "無指定"の時だけスライダー有効化（applyPreset(none)相当の処理）
        if (ui.presetRadios[0].checked) {
            ui.dampingSlider.disabled = false; 
            ui.impulseIntervalSlider.disabled = false;
        }
        
        update(); 
    });

    function calculateCompliance(enableBend, enableShear) {
        const E_phys = state.E * 1000000.0; 
        const G_phys = E_phys / (2 * (1 + NU));
        const A_area = state.a * state.b; 
        const I_phys = (state.b * Math.pow(state.a, 3)) / 12; 
        const L_phys = state.L; 

        const termBend = (Math.pow(L_phys, 3)) / (3 * E_phys * I_phys);
        const termShear = (G_phys * A_area > 0) ? (KAPPA * L_phys) / (G_phys * A_area) : 0;
        
        return (enableBend ? termBend : 0) + (enableShear ? termShear : 0);
    }

    function getNiceNumber(val) {
        if(val <= 0) return 100;
        const exponent = Math.floor(Math.log10(val));
        const fraction = val / Math.pow(10, exponent);
        let niceFraction;
        if (fraction <= 1.0) niceFraction = 1;
        else if (fraction <= 2.0) niceFraction = 2;
        else if (fraction <= 5.0) niceFraction = 5;
        else niceFraction = 10;
        return niceFraction * Math.pow(10, exponent);
    }

    // ★ 物理計算エンジンの修正：時間Δtを考慮したインパルス応答 ★
    function calculateDisplacement(t) {
        const E_phys = state.E * 1000000.0; 
        const A_area = state.a * state.b; 
        const L_phys = state.L; 
        const Mass = A_area * L_phys * RHO_CONC; 

        const total_comp = calculateCompliance(ui.toggleBending.checked, ui.toggleShear.checked);
        const Stiffness = (total_comp > 1e-10) ? (1.0 / total_comp) : 99999999; 
        const omega_n = Math.sqrt(Stiffness / Mass);
        const h = state.h;
        const omega_d = omega_n * Math.sqrt(Math.max(0, 1 - h*h));
        const Tn = (omega_n > 0) ? (2 * Math.PI / omega_n) : 0;

        let total_x = 0;
        let total_v = 0;

        for(let i=0; i<5; i++) {
            const mag = impulseState.magnitudes[i];
            if(mag <= 0.001) continue;

            const P_force = mag * impulseState.Pmax; 
            const t_i = (i + 1) * impulseState.intervalRatio * Tn;
            const dt = t - t_i;

            if (dt >= 0) {
                // v0 = (Force * Time) / Mass
                // これでkN単位の力を、一瞬(IMPULSE_DURATION)だけ加えた力積として扱う
                const v0 = (P_force * IMPULSE_DURATION) / Mass;
                
                const decay = Math.exp(-h * omega_n * dt);
                const sinVal = Math.sin(omega_d * dt);
                const cosVal = Math.cos(omega_d * dt);

                const x_i = (v0 / omega_d) * decay * sinVal;
                
                // 速度 v_i (微分)
                const v_i = v0 * decay * (cosVal - (h * omega_n / omega_d) * sinVal);

                total_x += x_i;
                total_v += v_i;
            }
        }

        return { x: total_x, v: total_v, stiffness: Stiffness, mass: Mass, p_ext: 0 };
    }

    let prevBend = ui.toggleBending.checked;
    let prevShear = ui.toggleShear.checked;

    function handleToggleChange() {
        const currBend = ui.toggleBending.checked;
        const currShear = ui.toggleShear.checked;
        prevBend = currBend;
        prevShear = currShear;
        if (!animState.isRunning) update();
    }

    ui.toggleBending.addEventListener('change', handleToggleChange);
    ui.toggleShear.addEventListener('change', handleToggleChange);

    function setupGraphScrubbing(canvas) {
        canvas.addEventListener('pointerdown', (e) => {
            if (!animState.isRunning && animState.time > 0) {
                isGraphScrubbing = true;
                scrubStartMouseX = e.clientX;
                canvas.setPointerCapture(e.pointerId);
            }
        });
        canvas.addEventListener('pointermove', (e) => {
            if (isGraphScrubbing) {
                const dx = e.clientX - scrubStartMouseX;
                scrubStartMouseX = e.clientX;
                const dt = dx * 0.005; 
                let targetTime = animState.time + dt;
                if (targetTime < 0) targetTime = 0;
                
                if (dt > 0) {
                    const step = 0.002; 
                    let t = animState.time;
                    while(t < targetTime) {
                        t += step;
                        if(t > targetTime) t = targetTime;
                        const res = calculateDisplacement(t);
                        const F_int = res.stiffness * res.x + (2 * state.h * Math.sqrt(res.mass * res.stiffness)) * res.v;
                        waveHistory.push({ t: t, x: res.x, v: res.v, p: res.p_ext, f: F_int });
                        if(t >= targetTime) break;
                    }
                } else {
                    waveHistory = waveHistory.filter(pt => pt.t <= targetTime);
                }
                animState.time = targetTime;
                update(); 
            }
        });
        canvas.addEventListener('pointerup', (e) => {
            isGraphScrubbing = false;
            canvas.releasePointerCapture(e.pointerId);
        });
    }
    
    setupGraphScrubbing(ui.timeCanvas);
    setupGraphScrubbing(ui.energyCanvas);


    function update() {
        const dt = animState.isRunning ? clock.getDelta() * animState.speed : 0;
        if (animState.isRunning) {
            animState.time += dt;
        }

        const E_phys = state.E * 1000000.0; 
        const G_phys = E_phys / (2 * (1 + NU));
        const A_area = state.a * state.b; 
        const I_phys = (state.b * Math.pow(state.a, 3)) / 12; 
        const L_phys = state.L; 

        const comp_b = (Math.pow(L_phys, 3)) / (3 * E_phys * I_phys);
        const comp_s = (G_phys * A_area > 0) ? (KAPPA * L_phys) / (G_phys * A_area) : 0;
        
        const active_comp_b = ui.toggleBending.checked ? comp_b : 0;
        const active_comp_s = ui.toggleShear.checked ? comp_s : 0;
        const total_comp = active_comp_b + active_comp_s;

        // Pmax再計算
        const Stiffness = (total_comp > 1e-10) ? (1.0 / total_comp) : 99999999; 
        const limitDisp = L_phys / 100.0; 
        const rawP = Stiffness * limitDisp;
        impulseState.Pmax = getNiceNumber(rawP);

        const calcRes = calculateDisplacement(animState.time);
        
        const disp_total_phys = calcRes.x;
        const v_current = calcRes.v;
        const Mass = calcRes.mass;
        const omega_n = Math.sqrt(Stiffness / Mass);
        const Tn = (omega_n > 0) ? (2 * Math.PI / omega_n) : 0;

        const F_restoring = Stiffness * disp_total_phys;
        const c_coeff = 2 * state.h * Math.sqrt(Mass * Stiffness);
        const F_damping = c_coeff * v_current;
        const F_internal = F_restoring + F_damping;
        
        const Ep = 0.5 * Stiffness * disp_total_phys * disp_total_phys;
        const Ek = 0.5 * Mass * v_current * v_current;
        const E_total = Ep + Ek;

        // Visuals Visibility Logic
        lHit.visible = true;
        hitRight.visible = true;
        hitTop.visible = true;
        cornerContainer.visible = true;
        eHit.visible = true;
        
        const showControls = (!animState.isRunning && animState.time === 0);
        const opacity = showControls ? 1 : 0;
        
        ui.labelL.style.opacity = opacity; 
        ui.labelHandleL.style.opacity = opacity;
        ui.labelHandle.style.opacity = opacity; 
        ui.labelHandleE.style.opacity = opacity;
        ui.labelA.style.opacity = opacity; 
        ui.labelB.style.opacity = opacity; 
        ui.labelE.style.opacity = opacity;
        
        if (!showControls) {
             lHit.visible = false;
             hitRight.visible = false;
             hitTop.visible = false;
             cornerContainer.visible = false;
             eHit.visible = false;
        }

        // ★★★ 修正: Tnの値をCanvas内に描画 ★★★
        const ctx = impulseCtx;
        const H_imp = ui.impulseCanvas.height;
        ctx.fillStyle = '#7f8c8d'; 
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'left';
        // 左下隅に描画 (originXは左マージン、originY + 45 あたりで下端付近)
        // CanvasのHeightはH。GRAPH_MARGIN_B=50。
        // X軸ラベルの下あたりを狙う
        ctx.fillText(`柱の固有周期 Tn = ${Tn.toFixed(3)} 秒`, 10, H_imp - 10);

        if (animState.isRunning) {
            waveHistory.push({ 
                t: animState.time, 
                x: disp_total_phys, 
                v: v_current, 
                p: 0,
                f: F_internal 
            });
            const cutoff = animState.time - 30.0;
            if (waveHistory.length > 0 && waveHistory[0].t < cutoff) {
                while(waveHistory.length > 0 && waveHistory[0].t < cutoff) {
                    waveHistory.shift();
                }
            }
            if (waveHistory.length > 4000) waveHistory.shift();
        } else if (animState.time === 0) {
             waveHistory = [{ t: 0, x: disp_total_phys, v: v_current, p: 0, f: F_internal }];
        }

        ui.resI.innerText = I_phys.toFixed(4); 
        ui.resT.innerText = Tn.toFixed(3); 
        ui.resTotal.innerText = disp_total_phys.toFixed(4);
        
        const theta_phys = (L_phys > 0) ? (disp_total_phys / L_phys) : 0;
        const thetaFrac = toInverseFraction(theta_phys);
        const thetaDisplay = `${theta_phys.toFixed(4)} rad (${thetaFrac})`;
        ui.resTheta.innerText = thetaDisplay;

        const visual_b = disp_total_phys * (active_comp_b/total_comp) * visualExaggeration; 
        const positions = columnMesh.geometry.attributes.position;
        const widthScale = 2.0; 
        const halfWidth = (state.a * widthScale) / 2;
        const redPos = redLines.geometry.attributes.position; let redIdx = 0; const redStep = SEGMENTS / 10;
        
        for (let i = 0; i <= SEGMENTS; i++) {
            const z_local = (i / SEGMENTS) * L_phys;
            const H = L_phys;
            const xi = z_local / H; 
            const norm_shape = 0.5 * (3 * Math.pow(xi, 2) - Math.pow(xi, 3));
            const x_bend = visual_b * norm_shape; 
            const centerX = x_bend;
            const theta_visual = Math.atan( (visual_b / (H * widthScale)) * (0.5 * (6 * xi - 3 * Math.pow(xi, 2))) ); 
            const cos = Math.cos(theta_visual), sin = Math.sin(theta_visual);
            const z_world = z_local * widthScale;
            positions.setXYZ(i*2,   centerX - halfWidth*cos, 0, z_world + halfWidth*sin); 
            positions.setXYZ(i*2+1, centerX + halfWidth*cos, 0, z_world - halfWidth*sin);
            if (i > 0 && i < SEGMENTS && i % redStep === 0) { 
                redPos.setXYZ(redIdx++, positions.getX(i*2), 0, positions.getZ(i*2)); 
                redPos.setXYZ(redIdx++, positions.getX(i*2+1), 0, positions.getZ(i*2+1)); 
            }
        }
        positions.needsUpdate = true; redPos.needsUpdate = true; columnWire.geometry.dispose(); columnWire.geometry = new THREE.EdgesGeometry(columnMesh.geometry);

        const drawA = state.a * widthScale; const drawB = state.b * widthScale;
        sectionRect.scale.set(drawA, drawB, 1); updateHatching(drawA, drawB, state.E);

        const halfA = drawA / 2; const halfB = drawB / 2;
        hitRight.position.set(halfA, 0, 0); hitTop.position.set(0, 0, halfB); cornerContainer.position.set(halfA, 0, halfB); eHit.position.set(-halfA, 0, -halfB);
        anchorTR.position.set(halfA, 0, halfB); anchorBL.position.set(-halfA, 0, -halfB);

        const xi_mid = 0.5;
        const norm_shape_mid = 0.5 * (3 * Math.pow(xi_mid, 2) - Math.pow(xi_mid, 3)); 
        const x_bend_mid = visual_b * norm_shape_mid;
        const centerX_mid = x_bend_mid;
        lHit.position.set(centerX_mid, 0, (L_phys * widthScale) / 2);

        updateLabelSpecial(ui.labelA, hitRight, 20, 5, 'left'); ui.labelA.innerText = `a = ${state.a.toFixed(1)}m`;
        updateLabelSpecial(ui.labelB, anchorTR, 0, -25, 'right'); ui.labelB.innerText = `b = ${state.b.toFixed(1)}m`;
        updateLabelSpecial(ui.labelHandle, anchorTR, 20, -10, 'left');
        
        updateLabelSpecial(ui.labelE, anchorBL, 0, 30, 'center'); ui.labelE.innerText = `E = ${state.E.toFixed(1)} kN/mm²`;
        updateLabelSpecial(ui.labelHandleE, anchorBL, -15, 0, 'right');
        
        if (showControls) {
            const leftEdgeOffset = new THREE.Vector3(-halfWidth, 0, 0); 
            updateLabelSpecial(ui.labelL, lHit, -85, 50, 'top-left', leftEdgeOffset); ui.labelL.innerText = `L = ${state.L.toFixed(1)}m`;
            updateLabelSpecial(ui.labelHandleL, lHit, -75, 15, 'top-left', leftEdgeOffset);
        }

        drawForceGraph(disp_total_phys, Stiffness, F_internal, 0, impulseState.Pmax); 
        drawTimeGraph(waveHistory, L_phys, animState.time, Tn, 0);
        drawEnergyGraph(waveHistory, L_phys, animState.time, Stiffness, Mass, E_total);
        drawModelSchematic(state, Mass);
        
        // ★修正点：引数に現在時刻を追加
        drawImpulseInput(Tn, animState.time);
        
        // ★修正: 応答波形分解グラフ (展開モード対応版) ★
        drawDecompositionGraph(Tn, Mass, Stiffness, state.h);

        // --- ★ 3D Arrow Animation (Revised: Instant Appear + Fade) Update ---
        const POST_FADE_TIME = 0.1; // 0.1s duration (Shortened)
        const currentTopX = visual_b; // 3D displacement X

        impulseArrows.forEach((arrow, i) => {
            const mag = impulseState.magnitudes[i];
            if(mag <= 0.01) { arrow.visible = false; return; }

            const t_impact = (i + 1) * impulseState.intervalRatio * Tn;
            const dt = animState.time - t_impact;

            if (dt >= 0 && dt <= POST_FADE_TIME) {
                arrow.visible = true;
                const arrowLen = 1.0 + mag * 1.5;
                
                // Fade out (1.0 -> 0.0)
                const opacity = 1.0 - (dt / POST_FADE_TIME);
                
                const currentLeftX = currentTopX - halfWidth;
                const topZ = L_phys * widthScale; 
                
                arrow.position.set(currentLeftX, 0, topZ);
                arrow.scale.set(arrowLen, 1, 1);
                
                arrow.children.forEach(c => {
                    c.material.opacity = opacity;
                });
            } else {
                arrow.visible = false;
            }
        });
    }

    // --- Drawing Functions ---
    // ★修正点：currentTime引数を追加
    function drawImpulseInput(Tn, currentTime) {
        const ctx = impulseCtx;
        const W = ui.impulseCanvas.width;
        const H = ui.impulseCanvas.height;
        ctx.clearRect(0, 0, W, H);
        
        // Update label text with seconds
        const intervalSec = impulseState.intervalRatio * Tn;
        ui.impulseLabelText.innerText = `インパルス間隔: ${impulseState.intervalRatio.toFixed(2)}×Tn (${intervalSec.toFixed(2)}秒)`;

        // 描画領域の計算
        const originX = GRAPH_MARGIN_L;
        const originY = H - GRAPH_MARGIN_B;
        const drawW = W - originX - 15;
        // マージン調整: 上部を広げて見切れ防止、下部を広げて重なり防止
        const topMargin = 30; 
        const drawH = originY - topMargin;

        // --- 軸の描画 (黒くっきり) ---
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        // Y軸
        ctx.moveTo(originX, 10); 
        ctx.lineTo(originX, originY);
        // X軸
        ctx.lineTo(W - 10, originY);
        ctx.stroke();

        // 軸ラベル
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 12px sans-serif';
        // Y軸ラベル「荷重(kN)」
        ctx.textAlign = 'left';
        ctx.fillText('荷重', 5, 15);
        ctx.fillText('(kN)', 5, 28);
        
        // X軸ラベル「時刻 (s)」
        ctx.textAlign = 'right';
        ctx.fillText('時刻 (s)', W - 5, H - 5);

        // オートスケール: Max時間 = intervalRatio * 6.0 程度
        const totalScale = impulseState.intervalRatio * 6.0; 
        const pxPerTn = drawW / totalScale;
        
        // --- グリッド線 (Tn, 2Tn...) 黒破線 ---
        ctx.beginPath();
        ctx.strokeStyle = '#000000'; 
        ctx.setLineDash([3, 4]); // 破線
        ctx.lineWidth = 1;
        
        // 画面内に入る分だけ描画
        for(let i=1; i * pxPerTn < drawW; i++) {
            const x = originX + i * pxPerTn;
            ctx.moveTo(x, 15); ctx.lineTo(x, originY);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // グリッドテキスト (Tn)
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        // 下部マージンを広げたので、軸の少し下に配置 (originY + 25)
        for(let i=1; i * pxPerTn < drawW; i++) {
             const x = originX + i * pxPerTn;
            ctx.fillText(`${i}Tn`, x, originY + 25); 
        }

        // --- インパルス (プロット: 丸のみ) ---
        const Pmax = impulseState.Pmax;

        for(let i=0; i<5; i++) {
            const mag = impulseState.magnitudes[i];
            
            // P1(index0) は t = 1*interval
            const tRatio = (i + 1) * impulseState.intervalRatio; 
            
            const centerX = originX + (tRatio / totalScale) * drawW;
            const barH = mag * drawH;
            const topY = originY - barH;
            
            ctx.fillStyle = impulseState.colors[i];
            
            // 1. プロット丸 (Dot) - 大きく
            const dotRadius = 10; 
            ctx.beginPath();
            ctx.arc(centerX, topY, dotRadius, 0, Math.PI*2);
            ctx.fill();

            // 2. 丸の中のラベル (P1...) - 白抜き文字
            ctx.fillStyle = '#ffffff'; 
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`P${i+1}`, centerX, topY);
            
            // 3. 数値表示 (丸の上) - 黒文字 - 実荷重
            ctx.fillStyle = '#000000'; 
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            const valForce = mag * Pmax;
            const valStr = valForce.toFixed(1);
            // 丸の上に表示
            ctx.fillText(valStr, centerX, topY - 12);
        }

        // ★★★ 追加: 現在時刻の赤線描画 ★★★
        if(currentTime > 0) {
            const t_max = totalScale * Tn;
            const currentX = originX + (currentTime / t_max) * drawW;

            if (currentX <= W && currentX >= originX) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(currentX, 10); 
                ctx.lineTo(currentX, originY);
                ctx.stroke();
            }
        }

        // ★★★ 修正: Tnの値をCanvas内に描画 ★★★
        ctx.fillStyle = '#7f8c8d'; // グレー
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'left';
        // 左下隅に描画 (originXは左マージン、originY + 45 あたりで下端付近)
        // CanvasのHeightはH。GRAPH_MARGIN_B=50。
        // X軸ラベルの下あたりを狙う
        ctx.fillText(`柱の固有周期 Tn = ${Tn.toFixed(3)} 秒`, 10, H - 10);
    }

    // ★ 応答波形分解グラフの描画（展開機能対応版） ★
    function drawDecompositionGraph(Tn, m, k, h) {
        const ctx = decompCtx;
        const W = ui.decompCanvas.width;
        const H = ui.decompCanvas.height;
        ctx.clearRect(0, 0, W, H);

        const originX = GRAPH_MARGIN_L;
        const drawW = W - originX - 15;

        // X軸スケールの共通設定
        const totalScale = impulseState.intervalRatio * 6.0; 
        const pxPerTn = drawW / totalScale;
        const t_max = totalScale * Tn;
        const dt_draw = t_max / drawW; 

        // ★★★ オートスケール計算（最大振幅の探索） ★★★
        const wn = Math.sqrt(k/m);
        const wd = wn * Math.sqrt(Math.max(0, 1 - h*h));
        
        let maxAbsVal = 0;
        // サンプリングステップを粗くして計算負荷を下げる(2pxごと)
        for(let px=0; px<=drawW; px+=2) {
            const t = px * dt_draw;
            let total_x = 0;
            for(let i=0; i<5; i++) {
                const mag = impulseState.magnitudes[i];
                if(mag <= 0.01) continue;
                const P_force = mag * impulseState.Pmax;
                const t_start = (i + 1) * impulseState.intervalRatio * Tn;
                if(t >= t_start) {
                    const dt = t - t_start;
                    const v0 = (P_force * IMPULSE_DURATION) / m;
                    const decay = Math.exp(-h * wn * dt);
                    total_x += (v0 / wd) * decay * Math.sin(wd * dt);
                }
            }
            if(Math.abs(total_x) > maxAbsVal) maxAbsVal = Math.abs(total_x);
        }
        if(maxAbsVal < 1e-6) maxAbsVal = 0.001;

        // Y軸スケール（全モード共通）: 最大変位が枠内に収まるように
        // 展開モード時も「合成波の最大値」を基準にスケールすることで、各波の相対的な大きさを表現する
        const scaleMaxDisp = maxAbsVal * 1.1; 
        
        // --- 描画モードによる分岐 ---
        if (!isDecompExpanded) {
            // ============ 従来（重ね合わせ）モード ============
            const originY = H/2; 
            const drawH_half = H/2 - 10;
            const yScale = drawH_half / scaleMaxDisp;

            // 軸・グリッド描画
            ctx.strokeStyle = '#000000'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(originX, 0); ctx.lineTo(originX, H); ctx.stroke(); 
            ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(W - 10, originY); ctx.stroke(); 
            ctx.beginPath(); ctx.strokeStyle = '#cccccc'; ctx.setLineDash([2, 2]); ctx.lineWidth = 1;
            for(let i=1; i * pxPerTn < drawW; i++) {
                const x = originX + i * pxPerTn;
                ctx.moveTo(x, 0); ctx.lineTo(x, H);
            }
            ctx.stroke(); ctx.setLineDash([]);

            // 数値表示 (修正: scaleMaxDispではなくmaxAbsVal(実測値)を使用)
            const maxForceEq = maxAbsVal * k;
            ctx.fillStyle = '#000000'; ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillText(`+${maxForceEq.toFixed(2)} kN`, 2, 2);
            ctx.textBaseline = 'bottom'; ctx.fillText(`-${maxForceEq.toFixed(2)} kN`, 2, H - 2);

            // 成分波描画
            for(let i=0; i<5; i++) {
                const mag = impulseState.magnitudes[i];
                if(mag <= 0.01) continue;
                const P_force = mag * impulseState.Pmax;
                const t_start = (i + 1) * impulseState.intervalRatio * Tn;
                const v0 = (P_force * IMPULSE_DURATION) / m;

                ctx.beginPath(); ctx.strokeStyle = impulseState.colors[i]; ctx.lineWidth = 1.5;
                let first = true;
                for(let px=0; px<=drawW; px++) {
                    const t = px * dt_draw; 
                    let x_val = 0;
                    if(t >= t_start) {
                        const dt = t - t_start;
                        const decay = Math.exp(-h * wn * dt);
                        x_val = (v0 / wd) * decay * Math.sin(wd * dt);
                    }
                    const screenX = originX + px;
                    const screenY = originY - x_val * yScale;
                    if(first) { ctx.moveTo(screenX, screenY); first = false; }
                    else { ctx.lineTo(screenX, screenY); }
                }
                ctx.stroke();
            }

            // 合成波描画
            ctx.beginPath(); ctx.strokeStyle = '#000000'; ctx.lineWidth = 2.5;
            let first = true;
            for(let px=0; px<=drawW; px++) {
                const t = px * dt_draw;
                let total_x = 0;
                for(let i=0; i<5; i++) {
                    const mag = impulseState.magnitudes[i];
                    if(mag <= 0.01) continue;
                    const P_force = mag * impulseState.Pmax;
                    const t_start = (i + 1) * impulseState.intervalRatio * Tn;
                    if(t >= t_start) {
                        const dt = t - t_start;
                        const v0 = (P_force * IMPULSE_DURATION) / m;
                        const decay = Math.exp(-h * wn * dt);
                        total_x += (v0 / wd) * decay * Math.sin(wd * dt);
                    }
                }
                const screenX = originX + px;
                const screenY = originY - total_x * yScale;
                if(first) { ctx.moveTo(screenX, screenY); first = false; }
                else { ctx.lineTo(screenX, screenY); }
            }
            ctx.stroke();

        } else {
            // ============ 展開（スタック）モード ============
            // 6つのエリアに分割: [0]:合成, [1]:P1 ... [5]:P5
            const slotCount = 6;
            const slotH = H / slotCount;
            const slotDrawH_half = slotH / 2 * 0.9; // マージン考慮
            const yScale = slotDrawH_half / scaleMaxDisp;

            // 共通X軸ラインとグリッド
            ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
            ctx.beginPath();
            for(let i=1; i * pxPerTn < drawW; i++) {
                const x = originX + i * pxPerTn;
                ctx.moveTo(x, 0); ctx.lineTo(x, H);
            }
            ctx.stroke(); ctx.setLineDash([]);
            
            // ★★★ 追加: 左端（t=0）の黒い縦軸 (貫通) ★★★
            ctx.beginPath();
            ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.setLineDash([]);
            ctx.moveTo(originX, 0); ctx.lineTo(originX, H);
            ctx.stroke();

            // 各スロットの描画
            for (let slot = 0; slot < slotCount; slot++) {
                const slotOriginY = slot * slotH + slotH / 2;
                
                // エリア区切り線
                if(slot > 0) {
                    ctx.beginPath(); ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 1;
                    ctx.moveTo(0, slot * slotH); ctx.lineTo(W, slot * slotH); ctx.stroke();
                }

                // ゼロ軸
                ctx.beginPath(); ctx.strokeStyle = '#7f8c8d'; ctx.lineWidth = 0.5;
                ctx.moveTo(originX, slotOriginY); ctx.lineTo(W - 10, slotOriginY); ctx.stroke();

                // ラベル
                ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                if (slot === 0) {
                     ctx.fillText("合成", 2, slotOriginY);
                } else {
                     ctx.fillStyle = impulseState.colors[slot-1];
                     ctx.fillText(`P${slot}`, 2, slotOriginY);
                }

                // 波形描画
                ctx.beginPath();
                if(slot === 0) { ctx.strokeStyle = '#000000'; ctx.lineWidth = 2.0; }
                else { ctx.strokeStyle = impulseState.colors[slot-1]; ctx.lineWidth = 1.5; }

                let first = true;
                for(let px=0; px<=drawW; px++) {
                    const t = px * dt_draw;
                    let val = 0;
                    
                    if (slot === 0) {
                        // 合成波計算
                        for(let i=0; i<5; i++) {
                            const mag = impulseState.magnitudes[i];
                            if(mag <= 0.01) continue;
                            const P_force = mag * impulseState.Pmax;
                            const t_start = (i + 1) * impulseState.intervalRatio * Tn;
                            if(t >= t_start) {
                                const dt = t - t_start;
                                const v0 = (P_force * IMPULSE_DURATION) / m;
                                const decay = Math.exp(-h * wn * dt);
                                val += (v0 / wd) * decay * Math.sin(wd * dt);
                            }
                        }
                    } else {
                        // 個別成分計算 (slot 1 -> P1 (index 0))
                        const idx = slot - 1;
                        const mag = impulseState.magnitudes[idx];
                        if(mag > 0.01) {
                            const P_force = mag * impulseState.Pmax;
                            const t_start = (idx + 1) * impulseState.intervalRatio * Tn;
                            if(t >= t_start) {
                                const dt = t - t_start;
                                const v0 = (P_force * IMPULSE_DURATION) / m;
                                const decay = Math.exp(-h * wn * dt);
                                val = (v0 / wd) * decay * Math.sin(wd * dt);
                            }
                        }
                    }

                    const screenX = originX + px;
                    const screenY = slotOriginY - val * yScale;
                    if(first) { ctx.moveTo(screenX, screenY); first = false; }
                    else { ctx.lineTo(screenX, screenY); }
                }
                ctx.stroke();
            }
        }
        
        // カレントタイムの赤い縦線 (共通)
        if(animState.isRunning || animState.time > 0) {
            const currentX = originX + (animState.time / t_max) * drawW;
            if(currentX <= W) {
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(currentX, 0); ctx.lineTo(currentX, H);
                ctx.stroke();
            }
        }
    }

    function drawModelSchematic(st, m) {
        const ctx = schematicCtx;
        const W = ui.schematicCanvas.width;
        const H = ui.schematicCanvas.height;
        ctx.clearRect(0, 0, W, H);
        const centerX = W / 2 - 10; const groundY = H - 20;
        ctx.beginPath(); ctx.moveTo(centerX - 50, groundY); ctx.lineTo(centerX + 50, groundY);
        ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke();
        ctx.beginPath(); ctx.lineWidth = 1;
        for(let x = centerX - 50; x <= centerX + 50; x += 8) { ctx.moveTo(x, groundY); ctx.lineTo(x - 4, groundY + 8); }
        ctx.stroke();
        const colWidth = 2 + st.a * 6; const colHeight = 50; const topY = groundY - colHeight;
        ctx.beginPath(); ctx.moveTo(centerX, groundY); ctx.lineTo(centerX, topY);
        ctx.moveTo(centerX + 0.5, groundY); ctx.lineTo(centerX + 0.5, topY);
        ctx.lineCap = 'butt'; ctx.lineWidth = colWidth; ctx.strokeStyle = '#000'; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(centerX - colWidth/2 - 2, groundY); ctx.lineTo(centerX + colWidth/2 + 2, groundY);
        ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.lineCap = 'round'; ctx.stroke();
        const radius = 6 + 5 * Math.pow(m, 1/3); 
        ctx.beginPath(); ctx.arc(centerX, topY - radius + 2, radius, 0, Math.PI*2);
        ctx.fillStyle = '#fff'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke();
        ctx.save(); ctx.clip(); ctx.beginPath(); ctx.lineWidth = 1;
        for(let x = centerX - radius - 10; x <= centerX + radius + 10; x += 5) { ctx.moveTo(x, topY - radius * 2); ctx.lineTo(x - 15, topY + radius * 2); }
        ctx.stroke(); ctx.restore();
        ctx.fillStyle = '#000'; ctx.font = '16px "Comic Sans MS", cursive, sans-serif'; 
        ctx.fillText('m', centerX + radius + 5, topY); ctx.fillText('k', centerX + 8 + colWidth/2, groundY - colHeight/2 + 5);

        const scale = radius / 12.0; 
        const cylinderW = 13 * scale; const cylinderH = 12 * scale; const rodLen = 15 * scale; 
        const sphereLeftX = centerX - radius; const damperY = topY - radius + 2; 
        const cylRightX = sphereLeftX - rodLen; const cylLeftX = cylRightX - cylinderW; const wallX = cylLeftX - rodLen;
        ctx.beginPath(); ctx.moveTo(wallX, groundY); ctx.lineTo(wallX, damperY - 15);
        ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke(); ctx.lineWidth = 1;
        for(let y = groundY; y > damperY - 15; y -= 6) { ctx.beginPath(); ctx.moveTo(wallX, y); ctx.lineTo(wallX - 4, y - 4); ctx.stroke(); }
        ctx.beginPath(); ctx.moveTo(wallX, damperY); ctx.lineTo(cylLeftX, damperY); ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.fillRect(cylLeftX, damperY - cylinderH/2, cylinderW, cylinderH); ctx.strokeRect(cylLeftX, damperY - cylinderH/2, cylinderW, cylinderH); 
        const shortLineLen = 5 * scale;
        ctx.beginPath(); ctx.moveTo(cylLeftX, damperY - cylinderH/2); ctx.lineTo(cylLeftX - shortLineLen, damperY - cylinderH/2);
        ctx.moveTo(cylLeftX, damperY + cylinderH/2); ctx.lineTo(cylLeftX - shortLineLen, damperY + cylinderH/2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cylRightX, damperY); ctx.lineTo(sphereLeftX, damperY); ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = '#000'; ctx.font = 'bold 14px sans-serif'; ctx.fillText('c', cylLeftX + cylinderW/2 - 3, damperY - cylinderH/2 - 5);
        
        // ★★★ P1-P5 arrow (RESTORED) ★★★
        const arrowX = centerX + radius + 15; const arrowY = topY - radius + 2; const arrowLen = 20;
        ctx.beginPath(); ctx.moveTo(arrowX, arrowY); ctx.lineTo(arrowX + arrowLen, arrowY);
        ctx.lineTo(arrowX + arrowLen - 5, arrowY - 3); ctx.moveTo(arrowX + arrowLen, arrowY); ctx.lineTo(arrowX + arrowLen - 5, arrowY + 3);
        ctx.lineWidth = 2; ctx.strokeStyle = '#27ae60'; ctx.stroke();
        ctx.fillStyle = '#27ae60'; ctx.font = 'bold 14px sans-serif'; ctx.fillText('P1～P5', arrowX, arrowY - 8);
    }

    function drawTimeGraph(data, L_phys, currentTime, period, staticDisp) {
        const ctx = timeCtx; const W = ui.timeCanvas.width; const H = ui.timeCanvas.height; ctx.clearRect(0, 0, W, H);
        const LEFT_MARGIN = 15; 
        let maxVal = 0; if (data.length > 0) { maxVal = data.reduce((max, p) => Math.max(max, Math.abs(p.x)), 0); }
        if (maxVal < 1e-6) maxVal = 1e-6;
        const displayLimit = maxVal * 1.2; 
        const TIME_WINDOW = 0.5; let startTime = 0; let endTime = TIME_WINDOW;
        if (currentTime > TIME_WINDOW) { endTime = currentTime; startTime = currentTime - TIME_WINDOW; }
        const toScreenX = (t) => LEFT_MARGIN + ((t - startTime) / TIME_WINDOW) * ((W - LEFT_MARGIN) * 0.95);
        const toScreenY = (x) => (H / 2) - (x / displayLimit) * (H / 2 * 0.9); 
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(LEFT_MARGIN, H/2); ctx.lineTo(W, H/2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(LEFT_MARGIN, 0); ctx.lineTo(LEFT_MARGIN, H); ctx.stroke();
        ctx.strokeStyle = '#ecf0f1';
        const startStep = Math.floor(startTime * 10); const endStep = Math.ceil(endTime * 10);
        ctx.fillStyle = '#000000'; ctx.font = '12px sans-serif';
        for(let step = startStep; step <= endStep; step++) {
            const t = step / 10.0; if (t < startTime) continue;
            const sx = toScreenX(t);
            ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, H); ctx.stroke();
            if (step % 5 === 0) {
                 ctx.textAlign = (step === endStep) ? 'right' : 'left';
                 ctx.fillText(t.toFixed(1) + 's', sx + (step === endStep ? -2 : 4), H - 5);
            }
        }
        ctx.textAlign = 'left';
        ctx.save(); ctx.beginPath(); ctx.rect(LEFT_MARGIN, 0, W - LEFT_MARGIN, H); ctx.clip();
        if (data.length > 1) {
            ctx.beginPath(); ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 2;
            let started = false;
            for(let i=0; i<data.length; i++) {
                const pt = data[i]; if (pt.t < startTime - 0.05) continue; 
                const sx = toScreenX(pt.t); const sy = toScreenY(pt.x);
                if (!started) { ctx.moveTo(sx, sy); started = true; } else { ctx.lineTo(sx, sy); }
            }
            ctx.stroke();
            const lastPt = data[data.length-1];
            if (lastPt) {
                const sx = toScreenX(lastPt.t); const sy = toScreenY(lastPt.x);
                ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.arc(sx, sy, 4, 0, Math.PI*2); ctx.fill();
            }
        }
        ctx.restore(); 
        ctx.fillStyle = '#000000'; ctx.font = 'bold 14px sans-serif';
        ctx.fillText('x', LEFT_MARGIN + 5, 15); ctx.fillText('t', W - 15, H/2 - 8);
        ctx.textAlign = 'right'; ctx.fillStyle = '#7f8c8d'; ctx.font = '11px Consolas, monospace';
        ctx.fillText('x = Total Disp', W - 5, 20);
        ctx.textAlign = 'left'; ctx.fillStyle = '#e67e22'; ctx.font = '12px monospace';
        ctx.fillText(`+${displayLimit.toFixed(3)}m`, LEFT_MARGIN + 5, 10);
        ctx.fillText(`-${displayLimit.toFixed(3)}m`, LEFT_MARGIN + 5, H - 2);
        ctx.textAlign = 'left';
    }

    function drawEnergyGraph(data, L_phys, currentTime, k, m, E_total) {
        const ctx = energyCtx; const W = ui.energyCanvas.width; const H = ui.energyCanvas.height; ctx.clearRect(0, 0, W, H);
        const LEFT_MARGIN = 15; const BOTTOM_MARGIN = 25; 
        let maxE = 0;
        if(data.length > 0) {
            maxE = data.reduce((max, pt) => {
                 const ep = 0.5 * k * pt.x * pt.x;
                 const ek = (pt.v !== undefined) ? 0.5 * m * pt.v * pt.v : 0;
                 return Math.max(max, ep + ek); 
            }, 0);
        }
        if (maxE < 1e-12) maxE = 1e-12; maxE *= 1.2;
        const TIME_WINDOW = 0.5; let startTime = 0; let endTime = TIME_WINDOW;
        if (currentTime > TIME_WINDOW) { endTime = currentTime; startTime = currentTime - TIME_WINDOW; }
        const toScreenX = (t) => LEFT_MARGIN + ((t - startTime) / TIME_WINDOW) * ((W - LEFT_MARGIN) * 0.95);
        const toScreenY = (e_val) => (H - BOTTOM_MARGIN) - (e_val / maxE) * (H * 0.85); 
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(LEFT_MARGIN, H - BOTTOM_MARGIN); ctx.lineTo(W, H - BOTTOM_MARGIN); ctx.stroke(); 
        ctx.beginPath(); ctx.moveTo(LEFT_MARGIN, 0); ctx.lineTo(LEFT_MARGIN, H); ctx.stroke(); 
        ctx.strokeStyle = '#ecf0f1';
        const startStep = Math.floor(startTime * 10); const endStep = Math.ceil(endTime * 10);
        ctx.fillStyle = '#000000'; ctx.font = '12px sans-serif';
        for(let step = startStep; step <= endStep; step++) {
            const t = step / 10.0; if (t < startTime) continue;
            const sx = toScreenX(t);
            ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, H - BOTTOM_MARGIN); ctx.stroke();
            if (step % 5 === 0) {
                 ctx.textAlign = (step === endStep) ? 'right' : 'left';
                 ctx.fillText(t.toFixed(1) + 's', sx + (step === endStep ? -2 : 4), H - 5);
            }
        }
        ctx.textAlign = 'left';
        ctx.save(); ctx.beginPath(); ctx.rect(LEFT_MARGIN, 0, W - LEFT_MARGIN, H); ctx.clip();
        if (data.length > 0) {
            ctx.beginPath(); ctx.moveTo(toScreenX(startTime), H - BOTTOM_MARGIN);
            for(let i=0; i<data.length; i++) {
                const pt = data[i]; if (pt.t < startTime - 0.05) continue;
                const Ep_val = 0.5 * k * pt.x * pt.x;
                const Ek_val = (pt.v !== undefined) ? 0.5 * m * pt.v * pt.v : 0;
                ctx.lineTo(toScreenX(pt.t), toScreenY(Ep_val + Ek_val));
            }
            if(data.length>0) ctx.lineTo(toScreenX(data[data.length-1].t), H - BOTTOM_MARGIN);
            ctx.closePath(); ctx.fillStyle = 'rgba(231, 76, 60, 0.6)'; ctx.fill();
            ctx.beginPath(); ctx.moveTo(toScreenX(startTime), H - BOTTOM_MARGIN);
            for(let i=0; i<data.length; i++) {
                const pt = data[i]; if (pt.t < startTime - 0.05) continue;
                const Ep_val = 0.5 * k * pt.x * pt.x;
                ctx.lineTo(toScreenX(pt.t), toScreenY(Ep_val));
            }
            if(data.length>0) ctx.lineTo(toScreenX(data[data.length-1].t), H - BOTTOM_MARGIN);
            ctx.closePath(); ctx.fillStyle = 'rgba(52, 152, 219, 1.0)'; ctx.fill();
            const sxCurr = toScreenX(currentTime); const syTotal = toScreenY(E_total);
            ctx.beginPath(); ctx.arc(sxCurr, syTotal, 3, 0, Math.PI*2); ctx.fillStyle = '#e74c3c'; ctx.fill();
        }
        ctx.restore(); 
        ctx.fillStyle = '#000000'; ctx.font = 'bold 14px sans-serif';
        ctx.fillText('E', LEFT_MARGIN + 5, 15); ctx.fillText('t', W - 15, H - BOTTOM_MARGIN - 5);
        ctx.textAlign = 'right'; ctx.fillStyle = '#e74c3c'; ctx.font = '12px monospace'; 
        ctx.fillText(`Scale: ${maxE.toFixed(3)} J`, W - 5, 10);
    }

    function drawForceGraph(currentDisp, k, F_internal, P_ext, P0_mag) {
        const ctx = graphCtx; const W = ui.graphCanvas.width; const H = ui.graphCanvas.height;
        const cx = W / 2; const cy = H / 2;
        ctx.clearRect(0, 0, W, H);

        let maxF_hist = 0;
        if (waveHistory.length > 0) {
             maxF_hist = waveHistory.reduce((m, p) => Math.max(m, Math.abs(p.f !== undefined ? p.f : p.x * k)), 0);
        }
        const currentAbsF = Math.abs(F_internal);
        const safeLimitF = Math.max(10.0, maxF_hist, currentAbsF);
        
        const K_VISUAL_BASE = 2000.0; 
        const safeLimitX = safeLimitF / K_VISUAL_BASE;

        const toScreenX = (x) => cx + (x / safeLimitX) * (W/2 * 0.9);
        const toScreenY = (f) => cy - (f / safeLimitF) * (H/2 * 0.9);

        // 軸描画
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(W, cy); ctx.stroke(); 
        ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, H); ctx.stroke();

        // 履歴線描画
        if (waveHistory.length > 1) {
            ctx.beginPath(); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 1;
            let first = true;
            for(let i=0; i<waveHistory.length; i++) {
                const pt = waveHistory[i];
                const f_val = (pt.f !== undefined) ? pt.f : (pt.x * k); 
                const sx = toScreenX(pt.x); const sy = toScreenY(f_val);
                if (first) { ctx.moveTo(sx, sy); first = false; } else { ctx.lineTo(sx, sy); }
            }
            ctx.stroke();
        }

        // 現在点
        const sx = toScreenX(currentDisp); const sy_int = toScreenY(F_internal);
        ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.arc(sx, sy_int, 5, 0, Math.PI*2); ctx.fill();

        // テキストラベル表示（軸の名前）
        ctx.fillStyle = '#000000'; ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'right'; ctx.fillText('x', W - 10, cy - 5); 
        ctx.textAlign = 'left'; ctx.fillText('F', cx + 5, 15);
        
        // --- 修正箇所：最大目盛り表示（グレー） ---
        // "Max:" を削除し、数値のみを表示
        ctx.fillStyle = '#95a5a6'; ctx.font = 'bold 11px monospace'; ctx.textAlign = 'right';
        ctx.fillText(`${safeLimitF.toFixed(1)}kN`, cx - 5, 12);
        
        // --- 最大値表示（黒色・2行表示） ---
        const ratioMax = maxF_hist / P0_mag;
        
        ctx.textAlign = 'left';
        ctx.font = 'bold 13px sans-serif';
        ctx.fillStyle = '#2c3e50'; 
        
        // 1行目：Fmaxの値
        ctx.fillText(`Fmax = ${maxF_hist.toFixed(2)} kN`, 8, 32);
        
        // 2行目：Po倍率
        ctx.fillText(`(Po × ${ratioMax.toFixed(2)})`, 8, 48);
    }

    function updateHatching(w, h, E) {
        const step = 0.25 / (E / 20.0); const minK = -w/2 - h/2; const maxK = w/2 + h/2;
        const positions = hatchLineGeo.attributes.position.array; let pIdx = 0;
        for(let k = minK; k <= maxK; k += step) {
            const points = [];
            let y1 = -w/2 - k; if (y1 >= -h/2 && y1 <= h/2) points.push(-w/2, y1);
            let y2 = w/2 - k; if (y2 >= -h/2 && y2 <= h/2) points.push(w/2, y2);
            let x1 = -h/2 + k; if (x1 > -w/2 && x1 < w/2) points.push(x1, -h/2); 
            let x2 = h/2 + k; if (x2 > -w/2 && x2 < w/2) points.push(x2, h/2);
            if (points.length >= 4 && pIdx + 6 < 1200) { 
                positions[pIdx++] = points[0]; positions[pIdx++] = points[1]; positions[pIdx++] = 0;
                positions[pIdx++] = points[2]; positions[pIdx++] = points[3]; positions[pIdx++] = 0;
            }
        }
        for(let i=pIdx; i<1200; i++) positions[i] = 0;
        hatchLineGeo.attributes.position.needsUpdate = true; hatchLineGeo.setDrawRange(0, pIdx / 3);
    }

    function updateLabelSpecial(el, targetObj, offsetX, offsetY, alignMode, offsetVecStr = new THREE.Vector3()) {
        const worldPos = new THREE.Vector3();
        targetObj.getWorldPosition(worldPos);
        worldPos.add(offsetVecStr); 
        const vec = worldPos.project(camera);
        const screenX = (vec.x * .5 + .5) * width + offsetX;
        const screenY = (vec.y * -.5 + .5) * height + offsetY;
        el.style.left = `${screenX}px`; el.style.top = `${screenY}px`;
        if (alignMode === 'left') el.style.transform = `translate(0, -50%)`; 
        else if (alignMode === 'right') el.style.transform = `translate(-100%, -50%)`; 
        else if (alignMode === 'top-left') el.style.transform = `translate(-100%, -100%)`;
        else el.style.transform = `translate(-50%, -50%)`;
    }

    canvasWrapper.addEventListener('pointermove', onPointerMove);
    canvasWrapper.addEventListener('pointerdown', onPointerDown);
    window.addEventListener('pointerup', onPointerUp);

    function onPointerMove(e) {
        if(animState.isRunning) {
            canvasWrapper.style.cursor = 'default';
            return; 
        }

        const rect = canvasWrapper.getBoundingClientRect();
        const mx = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const my = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        if (isDragging && activeHandle) {
            const type = activeHandle.userData.type;
            const widthScale = 2.0;

            if (type === 'dim') {
                const frustumHeight = 20; const frustumWidth = frustumHeight * aspect;
                const worldX = mx * (frustumWidth / 2);
                const worldZ = 3 + my * (frustumHeight / 2);
                const distZ = worldZ - SECTION_Z_POS - gizmoGroup.position.y; 
                const axis = activeHandle.userData.axis;
                let newValA = state.a, newValB = state.b;
                if (axis === 'a' || axis === 'both') newValA = (Math.abs(worldX) * 2) / widthScale;
                if (axis === 'b' || axis === 'both') newValB = (Math.abs(distZ) * 2) / widthScale;
                const clamp = (v) => Math.min(Math.max(Math.round(v * 10) / 10, 0.5), 2.0);
                state.a = clamp(newValA); state.b = clamp(newValB);
            
            } else if (type === 'E') {
                const dx = e.clientX - dragStartMouse.x; const dy = e.clientY - dragStartMouse.y;
                if(type === 'E') {
                    const change = (-dx + dy) * 0.1;
                    state.E = Math.min(Math.max(Math.round((dragStartVal + change) * 10) / 10, 10.0), 40.0);
                } 
            } else if (type === 'L') {
                const dy = -(e.clientY - dragStartMouse.y); 
                const worldDy = (dy / height) * 20; 
                let newL = (state.L * widthScale + worldDy * 0.1) / widthScale;
                state.L = Math.min(Math.max(newL, 1.2), 4.0);
            }
            
            update(); return;
        }

        mouse.set(mx, my); raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactables, true);
        
        hitRight.userData.visual.material.color.setHex(0x2980b9); hitTop.userData.visual.material.color.setHex(0x2980b9);
        cornerContainer.userData.visual.material.color.setHex(0x2980b9);
        eHit.userData.visual.material.color.setHex(0x27ae60);
        lVisual.material.color.setHex(0xffa500); 
        
        activeHandle = null; canvasWrapper.style.cursor = 'default';
        if (intersects.length > 0) {
            let obj = intersects[0].object;
            while(!obj.userData.isHandle && obj.parent) obj = obj.parent;
            if(obj.userData.isHandle){
                activeHandle = obj; canvasWrapper.style.cursor = 'pointer';
                const type = obj.userData.type;
                if(type === 'dim') { if(obj.userData.visual) obj.userData.visual.material.color.setHex(hoverColor); } 
                else if (type === 'E') obj.userData.visual.material.color.setHex(0x2ecc71);
                else if (type === 'L') obj.userData.visual.material.color.setHex(0xd35400); 
            }
        }
    }

    function onPointerDown(e) {
        if (activeHandle) {
            if (animState.isRunning) return;
            isDragging = true; canvasWrapper.style.cursor = 'grabbing';
            dragStartMouse.x = e.clientX; dragStartMouse.y = e.clientY;
            if (activeHandle.userData.type === 'E') dragStartVal = state.E;
            else if (activeHandle.userData.type === 'L') dragStartVal = state.L;
            else dragStartVal = 0;
            update();
        }
    }
    function onPointerUp() { isDragging = false; canvasWrapper.style.cursor = activeHandle ? 'pointer' : 'default'; update(); }
    
    function onResize() {
        const rect = canvasWrapper.getBoundingClientRect();
        width = rect.width; height = rect.height;
        renderer.setSize(width, height); aspect = width / height;
        camera.left = frustumSize * aspect / -2; camera.right = frustumSize * aspect / 2;
        camera.top = frustumSize / 2; camera.bottom = frustumSize / -2;
        camera.updateProjectionMatrix(); update();
        // ★修正点：リサイズ時にも再描画を実行し、画面消失を防ぐ★
        renderer.render(scene, camera);
    }
    window.addEventListener('resize', onResize);

    // ★★★ Correct Initialization Sequence ★★★
    function animate() {
        requestAnimationFrame(animate);
        update();
        renderer.render(scene, camera);
    }

    onResize(); 
    renderer.render(scene, camera);
    update();
    animate();

</script>
</body>
</html>